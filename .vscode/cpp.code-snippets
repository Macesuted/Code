{
    "Base": {
        "scope": "cpp",
        "prefix": [
            "template-Base"
        ],
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "bool mem1;",
            "",
            "void solve(void) { return; }",
            "",
            "bool mem2;",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "#ifdef LOCAL",
            "    cerr << \"Memory Cost: \" << abs(&mem1 - &mem2) / 1024. / 1024. << \"MB\" << endl;",
            "#endif",
            "",
            "    int _ = 1;",
            "    while (_--) solve();",
            "",
            "#ifdef LOCAL",
            "    cerr << \"Time Cost: \" << clock() * 1000. / CLOCKS_PER_SEC << \"MS\" << endl;",
            "#endif",
            "    return 0;"
        ]
    },
    "TopCoder": {
        "scope": "cpp",
        "prefix": [
            "template-TopCoder"
        ],
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef LOCAL",
            "",
            "bool mem1;",
            "",
            "#endif",
            "",
            "#define Class ClassName",
            "#define Method MethodName",
            "",
            "class Class {",
            "   private:",
            "   public:",
            "    void Method(void) {}",
            "};",
            "",
            "#ifdef LOCAL",
            "",
            "Class _;",
            "",
            "bool mem2;",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cerr << \"Memory Cost: \" << abs(&mem1 - &mem2) / 1024. / 1024. << \"MB\" << endl;",
            "",
            "    _.Method();",
            "",
            "    cerr << \"Time Cost: \" << clock() * 1000. / CLOCKS_PER_SEC << \"MS\" << endl;",
            "    return 0;",
            "}",
            "",
            "#endif"
        ]
    },
    "FastIO": {
        "scope": "cpp",
        "prefix": [
            "template-FastIO"
        ],
        "body": [
            "namespace IO {",
            "const int SIZE = 1 << 20;",
            "char Ibuf[SIZE], *Il = Ibuf, *Ir = Ibuf, Obuf[SIZE], *Ol = Obuf, *Or = Ol + SIZE - 1;",
            "int cache1[100], cache2[100];",
            "char isspace(char c) { return c == ' ' || c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r'; }",
            "char iseoln(char c) { return c == '\\n' || c == '\\r'; }",
            "void fill(void) { return Ir = (Il = Ibuf) + fread(Ibuf, 1, SIZE, stdin), void(); }",
            "void flush(void) { return fwrite(Obuf, 1, Ol - Obuf, stdout), Ol = Obuf, void(); }",
            "char buftop(void) { return Ir == Il && (fill(), 1), *Il; }",
            "char getch(void) { return Il == Ir ? fill(), Il == Ir ? EOF : *Il++ : *Il++; }",
            "void putch(char x) { return *Ol++ = x, Ol == Or && (flush(), 1), void(); }",
            "template <typename T = int>",
            "T read(void) {",
            "    T x = 0, f = +1;",
            "    char c = getch();",
            "    while (c < '0' || c > '9') (c == '-') && (f = -f), c = getch();",
            "    while ('0' <= c && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getch();",
            "    return x * f;",
            "}",
            "template <typename T>",
            "void write(T x) {",
            "    if (!x) return putch('0');",
            "    if (x < 0) putch('-'), x = -x;",
            "    int top = 0;",
            "    while (x) cache1[top++] = x % 10, x /= 10;",
            "    while (top) putch(cache1[--top] ^ 48);",
            "    return;",
            "}",
            "template <typename T>",
            "void writeDouble(T x, int dep = 10) {",
            "    if (x < 0) putch('-'), x = -x;",
            "    int64_t fx = x;",
            "    x -= fx;",
            "    for (int i = 0; i < dep; i++) cache2[i] = (x *= 10), x -= int(x);",
            "    if (int(x * 10) > 4) {",
            "        cache2[dep - 1]++;",
            "        for (int i = dep - 1; i; i--)",
            "            if (cache2[i] == 10) cache2[i] = 0, cache2[i - 1]++;",
            "        if (cache2[0] == 10) cache2[0] = 0, fx++;",
            "    }",
            "    write(fx), putch('.');",
            "    for (int i = 0; i < dep; i++) putch(cache2[i] ^ 48);",
            "    return;",
            "}",
            "string getstr(const string& suf = \"\") {",
            "    string s = suf;",
            "    while (isspace(buftop())) getch();",
            "    for (char* p = Il; Il != Ir; fill(), p = Il) {",
            "        while (Il < Ir && !isspace(*Il) && *Il != EOF) Il++;",
            "        s.append(p, Il);",
            "        if (Il < Ir) break;",
            "    }",
            "    return s;",
            "}",
            "string getline(const string& suf = \"\") {",
            "    string s = suf;",
            "    while (iseoln(buftop())) getch();",
            "    for (char* p = Il; Il != Ir; fill(), p = Il) {",
            "        while (Il < Ir && !iseoln(*Il) && *Il != EOF) Il++;",
            "        s.append(p, Il);",
            "        if (Il < Ir) break;",
            "    }",
            "    return s;",
            "}",
            "void putstr(string str, int begin = 0, int end = -1) {",
            "    if (end == -1) end = str.size();",
            "    for (int i = begin; i < end; i++) putch(str[i]);",
            "    return;",
            "}",
            "struct Flusher_ {",
            "    ~Flusher_() { flush(); }",
            "} io_flusher_;",
            "}  // namespace IO",
            "using IO::getch;",
            "using IO::getline;",
            "using IO::getstr;",
            "using IO::putch;",
            "using IO::putstr;",
            "using IO::read;",
            "using IO::write;",
            "using IO::writeDouble;"
        ]
    },
    "ModInt": {
        "scope": "cpp",
        "prefix": [
            "template-ModInt"
        ],
        "body": [
            "namespace MODINT {",
            "typedef __uint128_t uint128_t;",
            "uint64_t mod, qmod;",
            "void initMod(uint64_t x) { return qmod = (uint128_t(1) << 64) / (mod = x), void(); }",
            "template <typename T = uint32_t>",
            "class mint {",
            "   private:",
            "    T v;",
            "",
            "    T Lmod(uint64_t x) { return Smod(a - ((uint128_t(m) * a) >> 64) * mod); }",
            "    T Smod(T x) { return x >= mod ? x - mod : x; }",
            "",
            "    mint Pow(mint a, uint32_t x) {",
            "        mint ans = 1;",
            "        while (x) {",
            "            if (x & 1) ans *= a;",
            "            a *= a, x >>= 1;",
            "        }",
            "        return ans;",
            "    }",
            "    mint Inv(mint a) { return Pow(a, mod - 2); }",
            "",
            "   public:",
            "    mint(T o = 0) { v = o; }",
            "    T operator()(void) const { return v; }",
            "    mint operator+(const T& o) const { return Smod(v + o); }",
            "    mint operator-(const T& o) const { return Smod(v + mod - o); }",
            "    mint operator*(const T& o) const { return mint(Lmod((uint64_t)v * o)); }",
            "    mint operator/(const T& o) const { return mint(Lmod((uint64_t)v * Inv(o))); }",
            "    mint operator+(const mint& o) const { return *this + o(); }",
            "    mint operator-(const mint& o) const { return *this - o(); }",
            "    mint operator*(const mint& o) const { return *this * o(); }",
            "    mint operator/(const mint& o) const { return *this / o(); }",
            "    mint& operator=(const T& o) { return v = o, *this; }",
            "    mint& operator+=(const T& o) { return *this = *this + o; }",
            "    mint& operator-=(const T& o) { return *this = *this - o; }",
            "    mint& operator*=(const T& o) { return *this = *this * o; }",
            "    mint& operator/=(const T& o) { return *this = *this / o; }",
            "    mint& operator=(const mint& o) { return *this = o; }",
            "    mint& operator+=(const mint& o) { return *this = *this + o; }",
            "    mint& operator-=(const mint& o) { return *this = *this - o; }",
            "    mint& operator*=(const mint& o) { return *this = *this * o; }",
            "    mint& operator/=(const mint& o) { return *this = *this / o; }",
            "};",
            "};  // namespace MODINT",
            "using MODINT::initMod;",
            "using MODINT::mint;"
        ]
    }
}